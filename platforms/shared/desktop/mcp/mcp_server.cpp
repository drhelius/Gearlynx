/*
 * Gearlynx - Lynx Emulator
 * Copyright (C) 2025  Ignacio Sanchez

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/
 *
 */

#include "mcp_server.h"
#include "../utils.h"
#include <sstream>
#include <iomanip>
#include <fstream>
#include "log.h"

static void* ReaderThreadFunc(void* arg)
{
    McpServer* server = (McpServer*)arg;
    server->ReaderLoop();
    return NULL;
}

void McpServer::ReaderLoop()
{
    while (m_running.load())
    {
        std::string line;
        if (m_transport->recv(line))
        {
            if (!line.empty())
            {
                HandleLine(line);
            }
        }
        else
        {
            // EOF or error
            Stop();
            break;
        }
    }
}

void McpServer::Run()
{
    // Start reader thread for transport input
    std::thread reader_thread(ReaderThreadFunc, this);
    reader_thread.detach();

    // Transport thread waits for responses generated by the main thread
    // (via PumpCommands) and sends them back through the transport
    while (m_running.load())
    {
        DebugResponse* resp = m_responseQueue.WaitAndPop();
        if (resp == NULL)
            break;

        if (resp->isError)
        {
            SendError(resp->requestId, resp->errorCode, resp->errorMessage);
        }
        else
        {
            // Wrap result in MCP response format
            json mcpResult;
            mcpResult["content"] = json::array();

            // Check if this is image data (special marker from GetScreenshot)
            if (resp->result.contains("__mcp_image") && resp->result["__mcp_image"] == true)
            {
                // Image content type
                mcpResult["content"].push_back({
                    {"type", "image"},
                    {"data", resp->result["data"]},
                    {"mimeType", resp->result["mimeType"]}
                });
            }
            else
            {
                // Text content type (default)
                std::ostringstream result_ss;
                result_ss << resp->result.dump(2);

                mcpResult["content"].push_back({
                    {"type", "text"},
                    {"text", result_ss.str()}
                });
            }

            json response;
            response["jsonrpc"] = "2.0";
            response["id"] = resp->requestId;
            response["result"] = mcpResult;

            SendResponse(response);
        }

        SafeDelete(resp);
    }
}

void McpServer::HandleLine(const std::string& line)
{
    json request;

    // Try to parse JSON
    if (!json::accept(line))
    {
        SendError(0, -32700, "Parse error: Invalid JSON");
        return;
    }

    request = json::parse(line);

    // Validate JSON-RPC structure
    if (!request.contains("jsonrpc") || request["jsonrpc"] != "2.0")
    {
        SendError(0, -32600, "Invalid Request: missing or invalid jsonrpc version");
        return;
    }

    if (!request.contains("method") || !request["method"].is_string())
    {
        SendError(0, -32600, "Invalid Request: missing method");
        return;
    }

    std::string method = request["method"];

    // Handle different methods
    if (method == "initialize")
    {
        HandleInitialize(request);
    }
    else if (method == "notifications/initialized")
    {
        // Notifications don't need JSON-RPC response, but HTTP needs HTTP response
        if (dynamic_cast<HttpTransport*>(m_transport))
        {
            m_transport->send("{}");
        }
    }
    else if (method == "tools/list")
    {
        HandleToolsList(request);
    }
    else if (method == "tools/call")
    {
        HandleToolsCall(request);
    }
    else if (method == "resources/list")
    {
        HandleResourcesList(request);
    }
    else if (method == "resources/read")
    {
        HandleResourcesRead(request);
    }
    else
    {
        int64_t id = request.contains("id") ? request["id"].get<int64_t>() : 0;
        SendError(id, -32601, "Method not found: " + method);
    }
}

void McpServer::HandleInitialize(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    // Get protocol version from request
    std::string protocolVersion = "2025-11-25";
    if (request.contains("params") && request["params"].contains("protocolVersion"))
    {
        protocolVersion = request["params"]["protocolVersion"];
    }

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"protocolVersion", protocolVersion},
        {"capabilities", {
            {"tools", json::object()},
            {"resources", json::object()}
        }},
        {"serverInfo", {
            {"name", "gearlynx-mcp-server"},
            {"title", "Gearlynx MCP Server"},
            {"version", GLYNX_VERSION},
            {"description", "Debug and control Gearlynx Atari Lynx emulator. Provides tools for: stepping/pausing execution, breakpoints (address, range, IRQ), memory read/write, CPU/Mikey/Suzy register access, disassembly, screenshots, save states, controller input, and symbol management. Use for Lynx ROM debugging, reverse engineering, or automated testing."}
        }}
    };

    m_initialized = true;
    SendResponse(response);
}

void McpServer::HandleToolsList(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    json tools = json::array();

    // Execution control tools
    tools.push_back({
        {"name", "debug_pause"},
        {"title", "Pause Emulator"},
        {"description", "Pause Gearlynx emulator execution (break at current instruction)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_continue"},
        {"title", "Continue Execution"},
        {"description", "Resume Gearlynx emulator execution"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_step_into"},
        {"title", "Step Into"},
        {"description", "Step into next 6502 instruction (enters subroutines)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_step_over"},
        {"title", "Step Over"},
        {"description", "Step over next 6502 instruction (skips subroutines like JSR)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_step_out"},
        {"title", "Step Out"},
        {"description", "Step out of current subroutine (continues until RTS/RTI)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_step_frame"},
        {"title", "Step Frame"},
        {"description", "Step one video frame (executes until next VBLANK on Atari Lynx)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_reset"},
        {"title", "Reset System"},
        {"description", "Reset the Atari Lynx emulated system"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "debug_get_status"},
        {"title", "Get Debug Status"},
        {"description", "Get current debugger status (paused: idle state, at_breakpoint: stopped due to breakpoint hit, pc: address when paused)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    // Breakpoint tools
    tools.push_back({
        {"name", "set_breakpoint"},
        {"title", "Set Breakpoint"},
        {"description", "Set a breakpoint at specified address in Atari Lynx 64K address space"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., '8000', '0x8000', '$8000')"}
                }},
                {"read", {
                    {"type", "boolean"},
                    {"description", "Break on memory read (default: false). IMPORTANT: Read breakpoints stop with PC at the instruction after the memory access."}
                }},
                {"write", {
                    {"type", "boolean"},
                    {"description", "Break on memory write (default: false). IMPORTANT: Write breakpoints stop with PC at the instruction after the memory access."}
                }},
                {"execute", {
                    {"type", "boolean"},
                    {"description", "Break on execution (default: true)."}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "set_breakpoint_range"},
        {"title", "Set Range Breakpoint"},
        {"description", "Set a breakpoint for an address range in Atari Lynx 64K address space"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"start_address", {
                    {"type", "string"},
                    {"description", "Start address in hex (e.g., '8000')"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End address in hex (e.g., '8FFF')"}
                }},
                {"read", {
                    {"type", "boolean"},
                    {"description", "Break on memory read (default: false). IMPORTANT: Read breakpoints stop with PC at the instruction after the memory access."}
                }},
                {"write", {
                    {"type", "boolean"},
                    {"description", "Break on memory write (default: false). IMPORTANT: Write breakpoints stop with PC at the instruction after the memory access."}
                }},
                {"execute", {
                    {"type", "boolean"},
                    {"description", "Break on execution (default: true)."}
                }}
            }},
            {"required", json::array({"start_address", "end_address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_breakpoint"},
        {"title", "Remove Breakpoint"},
        {"description", "Clear a breakpoint. Must match how it was set: single address needs 'address' only, range needs both 'address' and 'end_address' with exact values."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., '8000'). For ranges: the start address"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End address in hex (e.g., '8FFF'). Required only for range breakpoints"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "list_breakpoints"},
        {"title", "List Breakpoints"},
        {"description", "List all breakpoints"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "set_breakpoint_on_irq"},
        {"title", "Set IRQ Breakpoint"},
        {"description", "Set a breakpoint to trigger on specific IRQ. IRQ types: 0=Timer0, 1=Timer1, 2=Timer2, 3=Timer3, 4=Timer4, 5=Timer5, 6=Timer6, 7=Timer7"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"irq", {
                    {"type", "integer"},
                    {"description", "IRQ number (0-7)"},
                    {"minimum", 0},
                    {"maximum", 7}
                }}
            }},
            {"required", json::array({"irq"})}
        }}
    });

    tools.push_back({
        {"name", "clear_breakpoint_on_irq"},
        {"title", "Clear IRQ Breakpoint"},
        {"description", "Clear a breakpoint on specific IRQ"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"irq", {
                    {"type", "integer"},
                    {"description", "IRQ number (0-7)"},
                    {"minimum", 0},
                    {"maximum", 7}
                }}
            }},
            {"required", json::array({"irq"})}
        }}
    });

    tools.push_back({
        {"name", "list_breakpoints_on_irq"},
        {"title", "List IRQ Breakpoints"},
        {"description", "List which IRQs have breakpoints set. Returns array of IRQ numbers (0=Timer0, 1=Timer1, 2=Timer2, 3=Timer3, 4=Timer4, 5=Timer5, 6=Timer6, 7=Timer7)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    // Memory tools
    tools.push_back({
        {"name", "list_memory_areas"},
        {"title", "List Memory Areas"},
        {"description", "List memory editor tabs. Returns CPU address range (e.g., RAM: $0000-$FFFF, STACK: $0100-$01FF, BIOS: $FE00-$FFFF). Use this to know what CPU addresses to request when reading/writing."},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "read_memory"},
        {"title", "Read Memory"},
        {"description", "Read memory from a specific memory area. Use list_memory_areas to get cpu_address_range for each area."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"offset", {
                    {"type", "string"},
                    {"description", "CPU address in hex matching the area's cpu_address_range"}
                }},
                {"size", {
                    {"type", "integer"},
                    {"description", "Number of bytes to read"}
                }}
            }},
            {"required", json::array({"area", "offset", "size"})}
        }}
    });

    tools.push_back({
        {"name", "write_memory"},
        {"title", "Write Memory"},
        {"description", "Write memory to a specific memory area. Use list_memory_areas to get cpu_address_range for each area."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"offset", {
                    {"type", "string"},
                    {"description", "CPU address in hex matching the area's cpu_address_range"}
                }},
                {"bytes", {
                    {"type", "string"},
                    {"description", "Hex bytes separated by spaces (e.g., 'A9 00 85 10')"}
                }}
            }},
            {"required", json::array({"area", "offset", "bytes"})}
        }}
    });

    // Register tools
    tools.push_back({
        {"name", "write_6502_register"},
        {"title", "Write CPU Register"},
        {"description", "Write to a 6502 CPU register"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"name", {
                    {"type", "string"},
                    {"description", "Register name (PC, A, X, Y, S, P)"}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "Hex value"}
                }}
            }},
            {"required", json::array({"name", "value"})}
        }}
    });

    // Disassembly tool
    tools.push_back({
        {"name", "get_disassembly"},
        {"title", "Get Disassembly"},
        {"description", "Get disassembled 6502 assembly code for an address range in the Atari Lynx 64K address space. "
                        "Returns: address, segment, mnemonic, and raw bytes. "
                        "NOTE: Disassembled records only exist for code that has been executed during emulation."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"start_address", {
                    {"type", "string"},
                    {"description", "Start address in hex (required). Accepts formats: 'E177', '0xE177', '$E177'"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End address in hex (required). Must be >= start_address. Accepts formats: 'E177', '0xE177', '$E177'"}
                }},
                {"resolve_symbols", {
                    {"type", "boolean"},
                    {"description", "When true, replace addresses in instruction mnemonics with user-defined symbol names and hardware register labels (e.g. 'LDA MY_VAR,X' instead of 'LDA $2C00,X'). Default: false"}
                }}
            }},
            {"required", json::array({"start_address", "end_address"})}
        }}
    });

    // Media info tool
    tools.push_back({
        {"name", "get_media_info"},
        {"title", "Get ROM Info"},
        {"description", "Get information about the loaded Atari Lynx ROM (file path, type, size, mapper, BIOS paths, etc.)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    // Chip status tools
    tools.push_back({
        {"name", "get_6502_status"},
        {"title", "Get CPU Status"},
        {"description", "Get 6502 CPU status (registers, flags, interrupts, memory map visibility based on MAPCTL)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_mikey_registers"},
        {"title", "Get Mikey Registers"},
        {"description", "Get Mikey registers ($FD00-$FDFF). Optionally filter by specific address."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Optional: specific register address to read (e.g., 'FD00', '0xFD00', '$FD00'). If omitted, returns all registers."}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "write_mikey_register"},
        {"title", "Write Mikey Register"},
        {"description", "Write to a Mikey register ($FD00-$FDFF)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Register address (e.g., 'FD00', '0xFD00', '$FD00')"}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "8-bit hex value (e.g., '12', '0x12', '$12')"}
                }}
            }},
            {"required", json::array({"address", "value"})}
        }}
    });

    tools.push_back({
        {"name", "get_mikey_timers"},
        {"title", "Get Mikey Timers"},
        {"description", "Get Mikey timer status (Timer 0-7). Optionally filter by specific timer."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"timer", {
                    {"type", "integer"},
                    {"description", "Optional: specific timer (0-7). If omitted, returns all timers."},
                    {"minimum", 0},
                    {"maximum", 7}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "get_mikey_audio"},
        {"title", "Get Mikey Audio"},
        {"description", "Get Mikey audio channel status (Channel 0-3). Optionally filter by specific channel."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"channel", {
                    {"type", "integer"},
                    {"description", "Optional: specific audio channel (0-3). If omitted, returns all channels."},
                    {"minimum", 0},
                    {"maximum", 3}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "get_suzy_registers"},
        {"title", "Get Suzy Registers"},
        {"description", "Get Suzy registers ($FC00-$FCFF). Optionally filter by specific address."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Optional: specific register address to read (e.g., 'FC00', '0xFC00', '$FC00'). If omitted, returns all registers."}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "write_suzy_register"},
        {"title", "Write Suzy Register"},
        {"description", "Write to a Suzy register ($FC00-$FCFF)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Register address (e.g., 'FC00', '0xFC00', '$FC00')"}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "8-bit hex value (e.g., '12', '0x12', '$12')"}
                }}
            }},
            {"required", json::array({"address", "value"})}
        }}
    });

    tools.push_back({
        {"name", "get_uart_status"},
        {"title", "Get UART Status"},
        {"description", "Get UART (ComLynx) status"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_cart_status"},
        {"title", "Get Cartridge Status"},
        {"description", "Get cartridge status (address generation, bank 0/1 info, AUDIN)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_eeprom_status"},
        {"title", "Get EEPROM Status"},
        {"description", "Get EEPROM status (type, size, mode, state, IO pins)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_lcd_status"},
        {"title", "Get LCD Status"},
        {"description", "Get LCD status (line number, type VISIBLE/VBLANK, cycle). Pixel and DMA info only on visible lines."},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_screenshot"},
        {"title", "Capture Screenshot"},
        {"description", "Capture current Atari Lynx screen frame as base64-encoded PNG image"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_frame_buffer"},
        {"title", "Get Frame Buffer"},
        {"description", "Capture a debug frame buffer as base64-encoded PNG image. VIDBAS is the Suzy video buffer address, DISPADR is the Mikey display address."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"buffer", {
                    {"type", "string"},
                    {"description", "Frame buffer to capture: 'vidbas' (Suzy) or 'dispadr' (Mikey)"},
                    {"enum", json::array({"vidbas", "dispadr"})}
                }}
            }},
            {"required", json::array({"buffer"})}
        }}
    });

    // Media and state management tools
    tools.push_back({
        {"name", "load_media"},
        {"title", "Load ROM"},
        {"description", "Load a ROM file (.lnx, .lyx, .o, .zip). Automatically loads .sym symbol file if present. Resets emulator on successful load"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"file_path", {
                    {"type", "string"},
                    {"description", "Absolute path to ROM file"}
                }}
            }},
            {"required", json::array({"file_path"})}
        }}
    });

    tools.push_back({
        {"name", "load_symbols"},
        {"title", "Load Symbols"},
        {"description", "Load debug symbols from file (.sym format with 'ADDRESS LABEL' entries). Adds to existing symbols"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"file_path", {
                    {"type", "string"},
                    {"description", "Absolute path to symbol file"}
                }}
            }},
            {"required", json::array({"file_path"})}
        }}
    });

    tools.push_back({
        {"name", "list_save_state_slots"},
        {"title", "List Save Slots"},
        {"description", "List all 5 save state slots with their information (rom name, timestamp, screenshot availability)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "select_save_state_slot"},
        {"title", "Select Save Slot"},
        {"description", "Select active save state slot (1-5) for save_state and load_state operations"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"slot", {
                    {"type", "integer"},
                    {"description", "Slot number (1-5)"},
                    {"minimum", 1},
                    {"maximum", 5}
                }}
            }},
            {"required", json::array({"slot"})}
        }}
    });

    tools.push_back({
        {"name", "save_state"},
        {"title", "Save State"},
        {"description", "Save emulator state to currently selected slot (use select_save_state_slot to change)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "load_state"},
        {"title", "Load State"},
        {"description", "Load emulator state from currently selected slot (use select_save_state_slot to change)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "set_fast_forward_speed"},
        {"title", "Set Fast Forward Speed"},
        {"description", "Set fast forward speed multiplier (0: 1.5x, 1: 2x, 2: 2.5x, 3: 3x, 4: Unlimited)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"speed", {
                    {"type", "integer"},
                    {"description", "Speed index (0-4)"},
                    {"minimum", 0},
                    {"maximum", 4}
                }}
            }},
            {"required", json::array({"speed"})}
        }}
    });

    tools.push_back({
        {"name", "toggle_fast_forward"},
        {"title", "Toggle Fast Forward"},
        {"description", "Toggle fast forward mode on or off. When enabled, emulator runs at configured speed (see set_fast_forward_speed)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"enabled", {
                    {"type", "boolean"},
                    {"description", "true to enable fast forward, false to disable"}
                }}
            }},
            {"required", json::array({"enabled"})}
        }}
    });

    // Controller input tools
    tools.push_back({
        {"name", "controller_button"},
        {"title", "Controller Button"},
        {"description", "Control a button on the Lynx controller. Use action 'press' to hold the button down, 'release' to let it go, or 'press_and_release' to simulate a quick button tap (presses and automatically releases after a few frames). Buttons: up, down, left, right, a, b, option1, option2, pause"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"button", {
                    {"type", "string"},
                    {"description", "Button name: up, down, left, right, a, b, option1, option2, pause"},
                    {"enum", json::array({"up", "down", "left", "right", "a", "b", "option1", "option2", "pause"})}
                }},
                {"action", {
                    {"type", "string"},
                    {"description", "Action to perform: 'press' holds the button, 'release' lets it go, 'press_and_release' simulates a quick tap"},
                    {"enum", json::array({"press", "release", "press_and_release"})}
                }}
            }},
            {"required", json::array({"button", "action"})}
        }}
    });

    // Disassembler tools
    tools.push_back({
        {"name", "debug_run_to_cursor"},
        {"title", "Run to Address"},
        {"description", "Continue execution until reaching specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177')"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "add_disassembler_bookmark"},
        {"title", "Add Disassembler Bookmark"},
        {"description", "Add a bookmark in the disassembler window at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177')"}
                }},
                {"name", {
                    {"type", "string"},
                    {"description", "Bookmark name (optional, auto-generated if not provided)"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_disassembler_bookmark"},
        {"title", "Remove Disassembler Bookmark"},
        {"description", "Remove a bookmark from the disassembler window at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177')"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "add_symbol"},
        {"title", "Add Symbol"},
        {"description", "Add a symbol (label) at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177', '0xE177', '$E177')"}
                }},
                {"name", {
                    {"type", "string"},
                    {"description", "Symbol name"}
                }}
            }},
            {"required", json::array({"address", "name"})}
        }}
    });

    tools.push_back({
        {"name", "remove_symbol"},
        {"title", "Remove Symbol"},
        {"description", "Remove a symbol from specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177', '0xE177', '$E177')"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    // Memory editor tools
    tools.push_back({
        {"name", "select_memory_range"},
        {"title", "Select Memory Range"},
        {"description", "Select a range of addresses in a memory editor tab"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"start_address", {
                    {"type", "string"},
                    {"description", "Start address in hex (e.g., '0100')"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End address in hex (e.g., '01FF')"}
                }}
            }},
            {"required", json::array({"area", "start_address", "end_address"})}
        }}
    });

    tools.push_back({
        {"name", "set_memory_selection_value"},
        {"title", "Fill Memory Selection"},
        {"description", "Set all bytes in current memory selection to specified value. Use get_memory_selection and select_memory_range to manage selection."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "Byte value in hex (e.g., 'FF' or '00')"}
                }}
            }},
            {"required", json::array({"area", "value"})}
        }}
    });

    tools.push_back({
        {"name", "add_memory_bookmark"},
        {"title", "Add Memory Bookmark"},
        {"description", "Add a bookmark in a memory area at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177', '0xE177', '$E177')"}
                }},
                {"name", {
                    {"type", "string"},
                    {"description", "Bookmark name (optional)"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_memory_bookmark"},
        {"title", "Remove Memory Bookmark"},
        {"description", "Remove a bookmark from a memory area at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177', '0xE177', '$E177')"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "add_memory_watch"},
        {"title", "Add Memory Watch"},
        {"description", "Add a watch (tracked memory location) in a memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177', '0xE177', '$E177')"}
                }},
                {"notes", {
                    {"type", "string"},
                    {"description", "Watch notes (optional)"}
                }},
                {"size", {
                    {"type", "integer"},
                    {"description", "Watch size in bits: 8, 16, 24, or 32 (default: 8)"},
                    {"enum", {8, 16, 24, 32}}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_memory_watch"},
        {"title", "Remove Memory Watch"},
        {"description", "Remove a watch from a memory area at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "Address in hex (e.g., 'E177', '0xE177', '$E177')"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "list_disassembler_bookmarks"},
        {"title", "List Disassembler Bookmarks"},
        {"description", "List all bookmarks in the disassembler"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "list_symbols"},
        {"title", "List Symbols"},
        {"description", "List all symbols (labels) defined in the disassembler"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "get_call_stack"},
        {"title", "Get Call Stack"},
        {"description", "List the current call stack (function calls hierarchy)"},
        {"inputSchema", {
            {"type", "object"},
            {"additionalProperties", false}
        }}
    });

    tools.push_back({
        {"name", "list_memory_bookmarks"},
        {"title", "List Memory Bookmarks"},
        {"description", "List all bookmarks in a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "list_memory_watches"},
        {"title", "List Memory Watches"},
        {"description", "List all watches in a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "get_memory_selection"},
        {"title", "Get Memory Selection"},
        {"description", "Get the current memory selection range for a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "memory_search_capture"},
        {"title", "Capture Memory Snapshot"},
        {"description", "Capture a snapshot of memory for comparison in searches"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "memory_search"},
        {"title", "Search Memory"},
        {"description", "Search memory for values matching criteria. Returns addresses and values found."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"operator", {
                    {"type", "string"},
                    {"description", "Comparison operator"},
                    {"enum", json::array({"<", ">", "==", "!=", "<=", ">="})}
                }},
                {"compare_type", {
                    {"type", "string"},
                    {"description", "What to compare against: 'previous' (snapshot), 'value' (specific value), or 'address' (value at specific address)"},
                    {"enum", json::array({"previous", "value", "address"})}
                }},
                {"compare_value", {
                    {"type", "integer"},
                    {"description", "Value to compare (for compare_type='value') or address to compare (for compare_type='address')"}
                }},
                {"data_type", {
                    {"type", "string"},
                    {"description", "Data type: 'unsigned' (default), 'signed', 'hex'"},
                    {"enum", json::array({"unsigned", "signed", "hex"})}
                }}
            }},
            {"required", json::array({"area", "operator", "compare_type"})}
        }}
    });

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"tools", tools}
    };

    SendResponse(response);
}

void McpServer::HandleToolsCall(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    if (!request.contains("params") || !request["params"].contains("name"))
    {
        SendError(id, -32602, "Invalid params: missing tool name");
        return;
    }

    std::string toolName = request["params"]["name"];
    json arguments = request["params"].contains("arguments") ? request["params"]["arguments"] : json::object();

    // Enqueue command for main thread to execute
    DebugCommand* cmd = new DebugCommand();
    cmd->requestId = id;
    cmd->toolName = toolName;
    cmd->arguments = arguments;
    m_commandQueue.Push(cmd);
}

json McpServer::ExecuteCommand(const std::string& toolName, const json& arguments)
{
    // Normalize tool name: VS Code converts underscores to dots
    std::string normalizedTool = toolName;
    size_t pos = 0;
    while ((pos = normalizedTool.find('.', pos)) != std::string::npos) {
        normalizedTool[pos] = '_';
        pos++;
    }

    // Execution control
    if (normalizedTool == "debug_pause")
    {
        m_debugAdapter.Pause();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_continue")
    {
        m_debugAdapter.Resume();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_into")
    {
        m_debugAdapter.StepInto();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_over")
    {
        m_debugAdapter.StepOver();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_out")
    {
        m_debugAdapter.StepOut();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_frame")
    {
        m_debugAdapter.StepFrame();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_reset")
    {
        m_debugAdapter.Reset();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_get_status")
    {
        return m_debugAdapter.GetDebugStatus();
    }
    // Breakpoints
    else if (normalizedTool == "set_breakpoint")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};

        bool read = arguments.value("read", false);
        bool write = arguments.value("write", false);
        bool execute = arguments.value("execute", true);

        if (!read && !write && !execute)
            return {{"error", "At least one of read, write, or execute must be true"}};

        m_debugAdapter.SetBreakpoint(address, read, write, execute);
        return {{"success", true}, {"address", addrStr}};
    }
    else if (normalizedTool == "set_breakpoint_range")
    {
        std::string startAddrStr = arguments["start_address"];
        std::string endAddrStr = arguments["end_address"];
        u16 start_address, end_address;

        if (!parse_hex_with_prefix(startAddrStr, &start_address))
            return {{"error", "Invalid start_address format"}};
        if (!parse_hex_with_prefix(endAddrStr, &end_address))
            return {{"error", "Invalid end_address format"}};
        if (start_address > end_address)
            return {{"error", "start_address must be <= end_address"}};

        bool read = arguments.value("read", false);
        bool write = arguments.value("write", false);
        bool execute = arguments.value("execute", true);

        if (!read && !write && !execute)
            return {{"error", "At least one of read, write, or execute must be true"}};

        m_debugAdapter.SetBreakpointRange(start_address, end_address, read, write, execute);
        return {{"success", true}, {"start_address", startAddrStr}, {"end_address", endAddrStr}};
    }
    else if (normalizedTool == "remove_breakpoint")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};

        // Check if end_address is provided for range breakpoints
        u16 end_address = 0;
        if (arguments.contains("end_address"))
        {
            std::string endAddrStr = arguments["end_address"];
            if (!parse_hex_with_prefix(endAddrStr, &end_address))
                return {{"error", "Invalid end_address format"}};
        }

        m_debugAdapter.ClearBreakpointByAddress(address, end_address);
        return {{"success", true}, {"address", addrStr}};
    }
    else if (normalizedTool == "list_breakpoints")
    {
        std::vector<BreakpointInfo> breakpoints = m_debugAdapter.ListBreakpoints();
        json bpArray = json::array();
        for (const BreakpointInfo& bp : breakpoints)
        {
            json bpObj;
            bpObj["enabled"] = bp.enabled;

            std::ostringstream addr_ss;
            addr_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << bp.address1;
            bpObj["address"] = addr_ss.str();

            if (bp.range)
            {
                std::ostringstream addr2_ss;
                addr2_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << bp.address2;
                bpObj["address2"] = addr2_ss.str();
            }

            bpObj["read"] = bp.read;
            bpObj["write"] = bp.write;
            bpObj["execute"] = bp.execute;
            bpArray.push_back(bpObj);
        }
        return {{"breakpoints", bpArray}};
    }
    else if (normalizedTool == "set_breakpoint_on_irq")
    {
        int irq = arguments["irq"];
        if (irq < 0 || irq > 7)
            return {{"error", "Invalid IRQ number (must be 0-7)"}};
        m_debugAdapter.SetBreakpointOnIRQ(irq);
        return {{"success", true}, {"irq", irq}};
    }
    else if (normalizedTool == "clear_breakpoint_on_irq")
    {
        int irq = arguments["irq"];
        if (irq < 0 || irq > 7)
            return {{"error", "Invalid IRQ number (must be 0-7)"}};
        m_debugAdapter.ClearBreakpointOnIRQ(irq);
        return {{"success", true}, {"irq", irq}};
    }
    else if (normalizedTool == "list_breakpoints_on_irq")
    {
        u8 mask = m_debugAdapter.GetBreakpointIRQMask();
        json irqList = json::array();
        const char* irqNames[] = {"Timer0", "Timer1", "Timer2", "Timer3", "Timer4", "Timer5", "Timer6", "Timer7"};
        for (int i = 0; i <= 7; i++)
        {
            if (mask & (1 << i))
            {
                irqList.push_back({{"irq", i}, {"name", irqNames[i]}});
            }
        }
        return {{"breakpoints", irqList}, {"count", irqList.size()}};
    }
    // Memory
    else if (normalizedTool == "list_memory_areas")
    {
        std::vector<MemoryAreaInfo> areas = m_debugAdapter.ListMemoryAreas();
        json areaArray = json::array();

        for (const MemoryAreaInfo& area : areas)
        {
            json areaObj;
            areaObj["id"] = area.id;
            areaObj["name"] = area.name;
            areaObj["size"] = area.size;

            // Calculate cpu_address_range from offset and size
            std::ostringstream range_ss;
            range_ss << "$" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << area.cpu_offset;
            range_ss << "-$" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << (area.cpu_offset + area.size - 1);
            areaObj["cpu_address_range"] = range_ss.str();

            areaArray.push_back(areaObj);
        }
        return {{"areas", areaArray}};
    }
    else if (normalizedTool == "read_memory")
    {
        int area = arguments["area"];
        std::string offsetStr = arguments["offset"];
        u32 offset;
        if (!parse_hex_with_prefix(offsetStr, &offset))
            return {{"error", "Invalid offset format"}};

        size_t size = arguments["size"];
        std::vector<u8> data = m_debugAdapter.ReadMemoryArea(area, offset, size);

        std::ostringstream hex_ss;
        for (size_t i = 0; i < data.size(); i++)
        {
            hex_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(2) << (int)data[i];
            if (i < data.size() - 1)
                hex_ss << " ";
        }

        return {{"area", area}, {"offset", offsetStr}, {"data", hex_ss.str()}};
    }
    else if (normalizedTool == "write_memory")
    {
        int area = arguments["area"];
        std::string offsetStr = arguments["offset"];
        u32 offset;
        if (!parse_hex_with_prefix(offsetStr, &offset))
            return {{"error", "Invalid offset format"}};

        std::string bytesStr = arguments["bytes"];
        std::vector<u8> data;

        // Parse hex bytes
        std::istringstream iss(bytesStr);
        std::string byteStr;
        while (iss >> byteStr)
        {
            u8 byte;
            if (!parse_hex_with_prefix(byteStr, &byte))
                return {{"error", "Invalid byte format"}};
            data.push_back(byte);
        }

        m_debugAdapter.WriteMemoryArea(area, offset, data);
        return {{"success", true}, {"area", area}, {"offset", offsetStr}, {"bytes_written", data.size()}};
    }
    // Registers
    else if (normalizedTool == "write_6502_register")
    {
        std::string name = arguments["name"];
        std::string valueStr = arguments["value"];
        u32 value;
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};

        m_debugAdapter.SetRegister(name, value);
        return {{"success", true}, {"register", name}, {"value", valueStr}};
    }
    // Disassembly
    else if (normalizedTool == "get_disassembly")
    {
        if (!arguments.contains("start_address"))
            return {{"error", "start_address is required"}};
        if (!arguments.contains("end_address"))
            return {{"error", "end_address is required"}};

        std::string startAddrStr = arguments["start_address"];
        std::string endAddrStr = arguments["end_address"];
        u16 start_address, end_address;

        if (!parse_hex_with_prefix(startAddrStr, &start_address))
            return {{"error", "Invalid start_address format"}};
        if (!parse_hex_with_prefix(endAddrStr, &end_address))
            return {{"error", "Invalid end_address format"}};
        if (start_address > end_address)
            return {{"error", "start_address must be <= end_address"}};

        bool resolve_symbols = false;
        if (arguments.contains("resolve_symbols") && arguments["resolve_symbols"].is_boolean())
            resolve_symbols = arguments["resolve_symbols"].get<bool>();

        std::vector<DisasmLine> lines = m_debugAdapter.GetDisassembly(start_address, end_address, resolve_symbols);

        json result;
        json instructions = json::array();

        for (const DisasmLine& line : lines)
        {
            json instr;
            std::ostringstream addr_ss, jump_ss;

            addr_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << line.address;

            instr["address"] = addr_ss.str();
            instr["segment"] = line.segment;
            instr["instruction"] = line.name;
            instr["bytes"] = line.bytes;
            instr["size"] = line.size;
            instr["rom"] = line.rom;

            if (line.jump)
            {
                jump_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << line.jump_address;
                instr["jump_target"] = jump_ss.str();
                instr["is_subroutine"] = line.subroutine;
            }

            if (line.irq > 0)
            {
                instr["irq"] = line.irq;
            }

            instructions.push_back(instr);
        }

        result["instructions"] = instructions;
        result["count"] = lines.size();
        result["start_address"] = startAddrStr;
        result["end_address"] = endAddrStr;

        if (lines.empty())
        {
            result["note"] = "No disassembly records found. You may have asked for code that has not been executed yet. Code is only disassembled as it is executed.";
        }

        return result;
    }
    // Media info
    else if (normalizedTool == "get_media_info")
    {
        return m_debugAdapter.GetMediaInfo();
    }
    // Chip status
    else if (normalizedTool == "get_6502_status")
    {
        return m_debugAdapter.Get6502Status();
    }
    else if (normalizedTool == "get_mikey_registers")
    {
        u16 address = 0xFFFF;
        if (arguments.contains("address"))
        {
            std::string addrStr = arguments["address"];
            if (!parse_hex_with_prefix(addrStr, &address))
                return {{"error", "Invalid address format"}};
        }
        return m_debugAdapter.GetMikeyRegisters(address);
    }
    else if (normalizedTool == "write_mikey_register")
    {
        std::string addrStr = arguments["address"];
        std::string valueStr = arguments["value"];

        u16 address;
        u16 value;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};

        return m_debugAdapter.WriteMikeyRegister(address, static_cast<u8>(value & 0xFF));
    }
    else if (normalizedTool == "get_mikey_timers")
    {
        int timer = arguments.value("timer", -1);
        return m_debugAdapter.GetMikeyTimers(timer);
    }
    else if (normalizedTool == "get_mikey_audio")
    {
        int channel = arguments.value("channel", -1);
        return m_debugAdapter.GetMikeyAudio(channel);
    }
    else if (normalizedTool == "get_suzy_registers")
    {
        u16 address = 0xFFFF;
        if (arguments.contains("address"))
        {
            std::string addrStr = arguments["address"];
            if (!parse_hex_with_prefix(addrStr, &address))
                return {{"error", "Invalid address format"}};
        }
        return m_debugAdapter.GetSuzyRegisters(address);
    }
    else if (normalizedTool == "write_suzy_register")
    {
        std::string addrStr = arguments["address"];
        std::string valueStr = arguments["value"];

        u16 address;
        u16 value;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};

        return m_debugAdapter.WriteSuzyRegister(address, static_cast<u8>(value & 0xFF));
    }
    else if (normalizedTool == "get_uart_status")
    {
        return m_debugAdapter.GetUARTStatus();
    }
    else if (normalizedTool == "get_cart_status")
    {
        return m_debugAdapter.GetCartStatus();
    }
    else if (normalizedTool == "get_eeprom_status")
    {
        return m_debugAdapter.GetEepromStatus();
    }
    else if (normalizedTool == "get_lcd_status")
    {
        return m_debugAdapter.GetLcdStatus();
    }
    else if (normalizedTool == "get_screenshot")
    {
        return m_debugAdapter.GetScreenshot();
    }
    else if (normalizedTool == "get_frame_buffer")
    {
        std::string buffer = arguments["buffer"];
        return m_debugAdapter.GetFrameBuffer(buffer);
    }
    // Media and state management
    else if (normalizedTool == "load_media")
    {
        std::string file_path = arguments["file_path"];
        return m_debugAdapter.LoadMedia(file_path);
    }
    else if (normalizedTool == "load_symbols")
    {
        std::string file_path = arguments["file_path"];
        return m_debugAdapter.LoadSymbols(file_path);
    }
    else if (normalizedTool == "list_save_state_slots")
    {
        return m_debugAdapter.ListSaveStateSlots();
    }
    else if (normalizedTool == "select_save_state_slot")
    {
        int slot = arguments["slot"];
        return m_debugAdapter.SelectSaveStateSlot(slot);
    }
    else if (normalizedTool == "save_state")
    {
        return m_debugAdapter.SaveState();
    }
    else if (normalizedTool == "load_state")
    {
        return m_debugAdapter.LoadState();
    }
    else if (normalizedTool == "set_fast_forward_speed")
    {
        int speed = arguments["speed"];
        return m_debugAdapter.SetFastForwardSpeed(speed);
    }
    else if (normalizedTool == "toggle_fast_forward")
    {
        bool enabled = arguments["enabled"];
        return m_debugAdapter.ToggleFastForward(enabled);
    }
    else if (normalizedTool == "controller_button")
    {
        std::string button = arguments["button"];
        std::string action = arguments["action"];
        return m_debugAdapter.ControllerButton(button, action);
    }
    // Disassembler operations
    else if (normalizedTool == "debug_run_to_cursor")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RunToAddress(address);
    }
    else if (normalizedTool == "add_disassembler_bookmark")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        std::string name = arguments.value("name", "");
        return m_debugAdapter.AddDisassemblerBookmark(address, name);
    }
    else if (normalizedTool == "remove_disassembler_bookmark")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveDisassemblerBookmark(address);
    }
    else if (normalizedTool == "add_symbol")
    {
        std::string addrStr = arguments["address"];
        std::string name = arguments["name"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.AddSymbol(address, name);
    }
    else if (normalizedTool == "remove_symbol")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveSymbol(address);
    }
    // Memory editor operations
    else if (normalizedTool == "select_memory_range")
    {
        int editor = arguments["area"];
        std::string startStr = arguments["start_address"];
        std::string endStr = arguments["end_address"];
        u32 start_address, end_address;
        if (!parse_hex_with_prefix(startStr, &start_address))
            return {{"error", "Invalid start_address format"}};
        if (!parse_hex_with_prefix(endStr, &end_address))
            return {{"error", "Invalid end_address format"}};
        return m_debugAdapter.SelectMemoryRange(editor, start_address, end_address);
    }
    else if (normalizedTool == "set_memory_selection_value")
    {
        int editor = arguments["area"];
        std::string valueStr = arguments["value"];
        u8 value;
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};
        return m_debugAdapter.SetMemorySelectionValue(editor, value);
    }
    else if (normalizedTool == "add_memory_bookmark")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        std::string name = arguments.value("name", "");
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.AddMemoryBookmark(editor, address, name);
    }
    else if (normalizedTool == "remove_memory_bookmark")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveMemoryBookmark(editor, address);
    }
    else if (normalizedTool == "add_memory_watch")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        std::string notes = arguments.value("notes", "");
        int size = arguments.value("size", 8);
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.AddMemoryWatch(editor, address, notes, size);
    }
    else if (normalizedTool == "remove_memory_watch")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveMemoryWatch(editor, address);
    }
    else if (normalizedTool == "list_disassembler_bookmarks")
    {
        return m_debugAdapter.ListDisassemblerBookmarks();
    }
    else if (normalizedTool == "list_symbols")
    {
        return m_debugAdapter.ListSymbols();
    }
    else if (normalizedTool == "get_call_stack")
    {
        return m_debugAdapter.ListCallStack();
    }
    else if (normalizedTool == "list_memory_bookmarks")
    {
        int area = arguments["area"];
        return m_debugAdapter.ListMemoryBookmarks(area);
    }
    else if (normalizedTool == "list_memory_watches")
    {
        int area = arguments["area"];
        return m_debugAdapter.ListMemoryWatches(area);
    }
    else if (normalizedTool == "get_memory_selection")
    {
        int area = arguments["area"];
        return m_debugAdapter.GetMemorySelection(area);
    }
    else if (normalizedTool == "memory_search_capture")
    {
        int area = arguments["area"];
        return m_debugAdapter.MemorySearchCapture(area);
    }
    else if (normalizedTool == "memory_search")
    {
        int area = arguments["area"];
        std::string op = arguments["operator"];
        std::string compare_type = arguments["compare_type"];
        int compare_value = arguments.value("compare_value", 0);
        std::string data_type = arguments.value("data_type", "unsigned");
        return m_debugAdapter.MemorySearch(area, op, compare_type, compare_value, data_type);
    }
    else
    {
        return {{"error", "Unknown tool: " + toolName}};
    }
}

void McpServer::SendResponse(const json& response)
{
    std::string line = response.dump();
    m_transport->send(line);
}

void McpServer::SendError(int64_t id, int code, const std::string& message, const json& data)
{
    json error;
    error["jsonrpc"] = "2.0";
    error["id"] = id;
    error["error"] = {
        {"code", code},
        {"message", message}
    };

    if (!data.empty() && !data.is_null())
    {
        error["error"]["data"] = data;
    }

    Log("[MCP] Sending error: %s", error.dump().c_str());

    SendResponse(error);
}

void McpServer::LoadResources()
{
    char exe_path[1024];
    get_executable_path(exe_path, sizeof(exe_path));

    if (exe_path[0] == '\0')
        return;

    std::string base_path = exe_path;
    std::string resourcesPath = base_path + "/mcp/resources";

    LoadResourcesFromCategory("hardware", resourcesPath + "/hardware/toc.json");
}

void McpServer::LoadResourcesFromCategory(const std::string& category, const std::string& tocPath)
{
    // Read toc.json file
    std::ifstream file(tocPath);
    if (!file.is_open())
    {
        // Resources directory not found, silently skip
        Log("[MCP] Warning: Resources TOC file not found: %s", tocPath.c_str());
        return;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    file.close();

    if (!json::accept(content))
    {
        Log("[MCP] Warning: Invalid JSON in resources TOC file: %s", tocPath.c_str());
        return;
    }

    json toc = json::parse(content);
    
    if (!toc.contains("toc") || !toc["toc"].is_array())
    {
        Log("[MCP] Warning: Invalid TOC format in resources TOC file: %s", tocPath.c_str());
        return;
    }

    // Get the directory containing toc.json
    std::string tocDir = tocPath.substr(0, tocPath.find_last_of("/\\"));

    for (const json& item : toc["toc"])
    {
        if (!item.contains("uri") || !item.contains("title"))
            continue;

        ResourceInfo resource;
        resource.uri = "gearlynx://" + category + "/" + item["uri"].get<std::string>();
        resource.title = item["title"].get<std::string>();
        resource.description = item.contains("description") ? item["description"].get<std::string>() : "";
        resource.mimeType = item.contains("mimeType") ? item["mimeType"].get<std::string>() : "text/plain";
        resource.category = category;
        resource.filePath = tocDir + "/" + item["uri"].get<std::string>() + ".md";

        m_resources.push_back(resource);
        m_resourceMap[resource.uri] = resource;
    }
}

std::string McpServer::ReadFileContents(const std::string& filePath)
{
    std::ifstream file(filePath);
    if (!file.is_open())
    {
        Log("[MCP] Warning: Failed to open resource file: %s", filePath.c_str());
        return "";
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}

void McpServer::HandleResourcesList(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    json resources = json::array();

    for (const ResourceInfo& resource : m_resources)
    {
        json resourceJson;
        resourceJson["uri"] = resource.uri;
        resourceJson["name"] = resource.title;
        resourceJson["title"] = resource.title;
        resourceJson["description"] = resource.description;
        resourceJson["mimeType"] = resource.mimeType;

        resources.push_back(resourceJson);
    }

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"resources", resources}
    };

    SendResponse(response);
}

void McpServer::HandleResourcesRead(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    if (!request.contains("params") || !request["params"].contains("uri"))
    {
        SendError(id, -32602, "Invalid params: missing uri");
        return;
    }

    std::string uri = request["params"]["uri"];

    // Find resource
    std::map<std::string, ResourceInfo>::const_iterator it = m_resourceMap.find(uri);
    if (it == m_resourceMap.end())
    {
        SendError(id, -32602, "Resource not found: " + uri);
        return;
    }

    const ResourceInfo& resource = it->second;
    std::string content = ReadFileContents(resource.filePath);

    if (content.empty())
    {
        SendError(id, -32602, "Failed to read resource file: " + resource.filePath);
        return;
    }

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"contents", json::array({
            {
                {"uri", resource.uri},
                {"mimeType", resource.mimeType},
                {"text", content}
            }
        })}
    };

    SendResponse(response);
}

